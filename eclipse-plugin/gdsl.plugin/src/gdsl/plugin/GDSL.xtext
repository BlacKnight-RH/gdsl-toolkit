grammar gdsl.plugin.GDSL hidden(WS, ML_COMMENT, SL_COMMENT)//with org.eclipse.xtext.common.Terminals

generate gDSL "http://www.plugin.gdsl/GDSL"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	decl += Decl (';'? decl += Decl)*
;

Decl:
	DeclGranularity | DeclExport | DeclType | DeclVal
;

DeclGranularity:
	name='granularity' '=' granularity=INTEGER
;

DeclExport:
	name='export' '=' exports+=Export*
;

DeclType:
	'type' name=ID 
	(('=' (=>(conDecl+=ConDecl ('|' conDecl+=ConDecl)*) | value=Ty))
	| ('[' attr+=ID (',' attr+=ID)* ']' '=' (conDecl+=ConDecl ('|' conDecl+=ConDecl)*)))
;

DeclVal:
	'val'
	(=>((name=ID | =>name=SYM) (attr += ID)* '=' exp=Exp) |
	((mid+=MID attr+=ID)* '=' exp=Exp) |
	( name=ID '[' decPat+=DECODEPAT* ']' (('=' exp=Exp) | ('|' exps+=Exp '=' exps+=Exp)+) ) )
;

Export:
	name=[DeclVal] ('{' attr+=ID (',' attr+=ID)* '}')?
;

ConDecl:
	name=CONS ('of' ty=Ty)?
;

Ty:
	value=INTEGER |
	'|' value=INTEGER '|' |
	(decl=[DeclType] | type='int') ('[' tyBind+=TyBind (',' tyBind+=TyBind)* ']')? |
	'{' elements+=TyElement (',' elements+=TyElement)* '}'
;

TyBind:
	name=ID ('=' value=Ty)?
;

TyElement:
	name=ID ':' value=Ty
;

Exp: 
	name=CaseExp | (mid+=MID caseExps+=CaseExp)+
;

CaseExp:
	ClosedExp |
	name='case' closedExp=ClosedExp 'of' (pat+=PAT ':' exp+=Exp ('|' pat+=PAT ':' exp+=Exp)*) 'end'
;

ClosedExp:
	OrElseExp |
	name='if' ifCaseExp=CaseExp 'then' thenCaseExp=CaseExp 'else' elseCaseExp=CaseExp |
	name='do' doExp+=MonadicExp (';' doExp+=MonadicExp)* 'end'
;

MonadicExp:
	=>exp=Exp |
	name=ID '<-' exp=Exp
;

OrElseExp:
	AndAlsoExp ({OrElseExp.left=current} name='or' right+=AndAlsoExp)*
;

AndAlsoExp:
	RExp ({AndAlsoExp.left=current} name='and' right+=RExp)*
;

RExp:
	AExp (=>sym+=SYM aexps+=AExp)*
;

AExp:
	MExp (sign+=('+'|'-') mexps+=MExp)*
;

MExp:
	SelectExp (symbol+=('*'|'%') applyexps+=ApplyExp)*
;

SelectExp:
	ApplyExp ('^' applyexps+=ApplyExp)*
;

ApplyExp:
	'~' AtomicExp |
	=>(atomicExp+=AtomicExp)+
;

AtomicExp:
	name=LIT |
	name=STRING |
	=>(name=CONS) |
	name=ID (=>DOT id+=ID)* |
	name='@' '{' fields+=Field (',' fields+=Field)* '}' |
	'$' name=ID |
	'(' expr=Exp ')' (=>DOT id+=ID)* |
	{AtomicExp} '{' (id+=ID '=' exps+=Exp (',' id+=ID '=' exps+=Exp)*)? '}' |
	name='let' valDecl+=ValueDecl+ 'in' expr=Exp 'end'
;

Field:
	name=ID '=' exp=Exp |
	'~' name=ID
;

ValueDecl:
	'val' name=ID ids+=ID* '=' exp=Exp
;

DECODEPAT: "'"BITPAT+"'" | TOKPAT;
TOKPAT: INTEGER | ID;
BITPAT: BINARY | (ID (BITPATORINT)?);
BITPATORINT: (':' POSINT) | ('@' BINARY);
PAT: USCORE | LIT | =>CONS PAT? | ID ;
LIT: INTEGER | "'"BINARY?"'";
ID: CONS | ID_WO_CONS | SLASH;
MID: MIXID | USCORE;
SYM: USCORE| SLASH | BS | DOT | SYM_WO_USCORE_WO_SLASH_WO_BS_WO_DOT;
INTEGER: POSINT | NEGINT;
POSINT: POSINT_WO_DUALS | DUALS;
BINARY: DUALS | BINS | BS | DOT;

terminal USCORE:'_';
terminal SLASH:'/';
terminal BS:'\\';
terminal DOT:'.';
terminal SYM_WO_USCORE_WO_SLASH_WO_BS_WO_DOT: (CHARSYM|OTHERSYM)+;
terminal MIXID:'_'(USCORE|IDCHAR)*;
terminal CONS:('A'..'Z') (USCORE|IDCHAR)*;
terminal ID_WO_CONS:('A'..'Z'|'a'..'z'|'/') (USCORE|IDCHAR)*;
terminal STRING:'"' ( '\\'('b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\') | !('\\'|'"') )* '"';
terminal fragment IDCHAR:('A'..'Z'|'a'..'z'|'/'|'0'..'9'|CHARSYM);
terminal fragment CHARSYM:/*'_'|*/'-'|'?'/*|"'"*/|'!';
terminal fragment OTHERSYM:'%'|'&'|'$'|'+'|':'|'<'|'='|'>'|'@'|'~'|'`'|'^'/*|'#'*/|'*';
terminal DUALS: ('0'|'1')+;
terminal BINS:('0'|'1'|'\\'|'.'|'|')*;
terminal POSINT_WO_DUALS: ('0'..'9')+|('0x'('A'..'F'|'a'..'f'|'0'..'9')+);
terminal NEGINT: '~'('0'..'9')+;

terminal WS: (' '|'\t'|'\r'|'\n')+;
terminal ML_COMMENT	: '(*' -> '*)';
terminal SL_COMMENT 	: '#' !('\n')* '\n';

