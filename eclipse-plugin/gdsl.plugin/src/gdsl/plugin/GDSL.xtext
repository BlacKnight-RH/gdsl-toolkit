grammar gdsl.plugin.GDSL hidden(WS, ML_COMMENT, SL_COMMENT)//with org.eclipse.xtext.common.Terminals

generate gDSL "http://www.plugin.gdsl/GDSL"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model:
	decl += Decl (';'? decl += Decl)*
;

//*****************************
Decl:
	DeclGranularity | DeclExport | DeclType | DeclVal
;

//*****************************
DeclGranularity:
	name='granularity' '=' granularity=Int
;

DeclExport:
	name='export' '=' exports+=Export*
;

DeclType:
	'type' name=Name (
		('=' =>value=ConDecls | value=Ty) | 
		('[' attrName+=Name (',' attrName+=Name)* ']' '=' value=ConDecls)
	)
;

DeclVal:
	'val' (name=Name | =>name=SYM) (attr += Name)* '=' exp=Exp |
	'val' (mid+=MIXID attr+=Name)* '=' exp=Exp |
	'val' name=Name '[' (decPat+=DecodePat (decPat+=DecodePat)*)? ']' (('=' exp=Exp) | (PIPE exps+=Exp '=' exps+=Exp)+)
;


//*****************************
Export:
	name=Qid ('{' attrName+=Name (',' attrName+=Name)* '}')?
;

ConDecls:
	conDecls+=ConDecl (PIPE conDecls+=ConDecl)*
;

ConDecl:
	name=ConBind ('of' ty=Ty)?
;

Ty:
	value=Int |
	PIPE value=Int PIPE |
	value=Qid ('[' tyBind+=TyBind (',' tyBind+=TyBind)* ']')? |
	'{' elements+=TyElement (',' elements+=TyElement)* '}'
;

TyElement:
	name=Name ':' value=Ty
;

TyBind:
	key=Qid ('=' value=Ty)?
;

DecodePat:
	BitPat | TokPat
;

BitPat:
	"'"  bitpat+=PrimBitPat (bitpat+=PrimBitPat)* "'"
;

TokPat:
	tokPat = (Int | Qid)
;

Exp: 
	caseExp=CaseExp | mid=MIXID caseExp=CaseExp
;

CaseExp:
	ClosedExp |
	'case' closedExp=ClosedExp 'of' cases=Cases 'end'
;

ClosedExp:
	OrElseExp |
	'if' ifCaseExp=CaseExp 'then' thenCaseExp=CaseExp 'else' elseCaseExp=CaseExp |
	'do' doExp+=MonadicExp (';' doExp+=MonadicExp)* 'end'
;

MonadicExp:
	=>exp=Exp |
	name=Name '<-' exp=Exp
;

Cases:
	pat+=Pat ':' exp+=Exp (PIPE pat+=Pat ':' exp+=Exp)*
;

OrElseExp:
	AndAlsoExp ({OrElseExp.left=current} 'or' right+=AndAlsoExp)*
;

AndAlsoExp:
	RExp ({AndAlsoExp.left=current} 'and' right+=RExp)*
;

RExp:
	aexp=AExp (=>sym+=SYM aexps+=AExp)*
;

AExp:
	mexp=MExp (sign+=('+'|'-') mexps+=MExp)*
;

MExp:
	applyexps+=ApplyExp ('^' applyexps+=ApplyExp)*
;

ApplyExp:
	(neg?='~')? =>exp=AtomicExp
;

AtomicExp:
	{AtomicExp} Lit |
	{AtomicExp} String |
	=>id+=Qid (=>DOT id+=Qid)* |
	{AtomicExp} ConUse |
	'@' '{' fields+=Field (',' fields+=Field)* '}' |
	{AtomicExp} '$' Qid |
	'(' exp=Exp ')' (=>DOT id+=Qid)* |
	{AtomicExp} '{' (id+=Name '=' exps+=Exp (=>id+=Name '=' exps+=Exp)*)? '}' |
	'let' valDecl+=ValueDecl+ 'in' exp=Exp 'end'
;

Field:
	name=Name '=' exp=Exp |
	'~' name=Name
;

ValueDecl:
	'val' Name Name* '=' Exp
;

String:
	'"' STRCHAR* '"'
;

//DataType Rules
Pat: '_' | Lit | =>Name | ConUse Pat?;
Lit: Int | "'" BITSTR? "'";
PrimBitPat: =>BITSTR | (Qid (BitPatOrInt)?);
BitPatOrInt: (':' POSINT) | ('@' BITSTR);
Int: POSINT | NEGINT;
Name: ID;
ConBind: CONS;
ConUse: CONS;
Qid: ID;

POSINT: NUM | HEXNUM;
NEGINT: '~' NUM;
NUM: =>DIG+;
HEXNUM: '0x' =>HEXDIGIT+;
SYMID: SYM+;
BITSTR: =>BINARY+;
MIXID: '_' =>IDCHAR+;
CONS: ULETTER =>IDCHAR*;

ID: LETTER =>IDCHAR*;
STRCHAR: LETTER; //TODO
HEXDIGIT: DIG | HEXCHAR;
HEXCHAR: LHEXCHAR | UHEXCHAR;
ULETTER: UHEXCHAR | UNHEXCHAR;
LETTER: LHEXCHAR | LNHEXCHAR | ULETTER | SLASH;
IDCHAR: LETTER | DIG | CHARSYM;
BINARY: BINDIG | BS | DOT | PIPE;
DIG: BINDIG | NBINDIG;
SYM: BS | SLASH | DOT | CHARSYM | OTHERSYM;


//Terminal symbols	

//terminal BITSTRIDCHAR: 'bistridchar';//LETTER | DIG | '_' | '-' | '?' | '!';
//terminal BITSTRID: 'bitstrid';//LETTER BITSTRIDCHAR*;
//terminal ESC: 'esc';//'\\' (('a'|'b'|'f'|'n'|'r'|'t'|'v'|'\\'|'\"') | (DIG DIG DIG));
//terminal SGOOD: 'sgoodtodo'; //TODO

terminal BINDIG: '0'|'1';
terminal NBINDIG: ('2'..'9');
terminal LHEXCHAR: ('a'..'f');
terminal UHEXCHAR: ('A'..'F');
terminal LNHEXCHAR: ('g'..'z');
terminal UNHEXCHAR: ('G'..'Z');
terminal BS: '\\';
terminal SLASH: '/';
terminal DOT: '.';
terminal PIPE: '|';
terminal CHARSYM: '_'|'-'|'?'|"'"|'!';
terminal OTHERSYM: '%'|'&'|'$'|'+'|':'|'<'|'='|'>'|'@'|'~'|'`'|'^'|'#'|'*';

terminal WS: (' '|'\t'|'\r'|'\n')+; //TODO
terminal ML_COMMENT	: '(*' -> '*)';
terminal SL_COMMENT 	: '#' !('\n')* '\n';
